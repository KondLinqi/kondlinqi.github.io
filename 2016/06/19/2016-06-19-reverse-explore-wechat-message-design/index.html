<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS开发," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="TOC{:toc}


背景工作中自己负责IM功能的开发，平时对微信进行了不少研究学习。这篇文章主要关注微信iOS客户端界面实现中的“聊天消息界面”实现。
写这篇文章的目的：

分享微信的聊天界面实现方式。
展示逆向主要流程。

PS: 最初是为了解决项目中的一个小问题才逆向的微信。
准备设备：iPhone5 iOS 8.4 越狱
usbmuxd
123➜  python-client pyth">
<meta property="og:type" content="article">
<meta property="og:title" content="逆向探索微信消息界面实现">
<meta property="og:url" content="http://yoursite.com/2016/06/19/2016-06-19-reverse-explore-wechat-message-design/index.html">
<meta property="og:site_name" content="leneqi blog">
<meta property="og:description" content="TOC{:toc}


背景工作中自己负责IM功能的开发，平时对微信进行了不少研究学习。这篇文章主要关注微信iOS客户端界面实现中的“聊天消息界面”实现。
写这篇文章的目的：

分享微信的聊天界面实现方式。
展示逆向主要流程。

PS: 最初是为了解决项目中的一个小问题才逆向的微信。
准备设备：iPhone5 iOS 8.4 越狱
usbmuxd
123➜  python-client pyth">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1465648981061.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1465649157982.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1465664951065.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1465666569528.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1465836652040.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1465992949249.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466097350949.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466097381889.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466104472059.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466141798790.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466238259094.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466242953914.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466240808797.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466240901871.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466241021593.png">
<meta property="og:image" content="https://everettjf.github.io/stuff/eimkit/1466241507427.png">
<meta property="og:updated_time" content="2016-06-25T12:41:40.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="逆向探索微信消息界面实现">
<meta name="twitter:description" content="TOC{:toc}


背景工作中自己负责IM功能的开发，平时对微信进行了不少研究学习。这篇文章主要关注微信iOS客户端界面实现中的“聊天消息界面”实现。
写这篇文章的目的：

分享微信的聊天界面实现方式。
展示逆向主要流程。

PS: 最初是为了解决项目中的一个小问题才逆向的微信。
准备设备：iPhone5 iOS 8.4 越狱
usbmuxd
123➜  python-client pyth">
<meta name="twitter:image" content="https://everettjf.github.io/stuff/eimkit/1465648981061.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2016/06/19/2016-06-19-reverse-explore-wechat-message-design/"/>

  <title> 逆向探索微信消息界面实现 | leneqi blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

        <a href="https://github.com/hhstore"><img style="position: absolute; top: 500; left: 0; border: 0;" src="https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png"></a>


    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">leneqi blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">喜欢代码,爱好设计与音乐</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/home" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tools">
          <a href="/tools" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            工具
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                逆向探索微信消息界面实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-06-19T00:00:00+08:00" content="2016-06-19">
              2016-06-19
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/06/19/2016-06-19-reverse-explore-wechat-message-design/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/06/19/2016-06-19-reverse-explore-wechat-message-design/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          
          <span id="busuanzi_container_page_pv">  |  阅读量 <span id="busuanzi_value_page_pv"></span> 次</span>
        
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li>TOC<br>{:toc}</li>
</ul>
<hr>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>工作中自己负责IM功能的开发，平时对微信进行了不少研究学习。<br>这篇文章主要关注微信iOS客户端界面实现中的“聊天消息界面”实现。</p>
<p>写这篇文章的目的：</p>
<ul>
<li>分享微信的聊天界面实现方式。</li>
<li>展示逆向主要流程。</li>
</ul>
<p>PS: 最初是为了解决项目中的<a href="https://everettjf.github.io/2016/06/18/little-chat-ui-bug-resolve" target="_blank" rel="external">一个小问题</a>才逆向的微信。</p>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>设备：iPhone5 iOS 8.4 越狱</p>
<p>usbmuxd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  python-client python tcprelay.py -t 22:2222</span><br><span class="line">Forwarding local port 2222 to remote port 22</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>ssh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@localhost -p 2222</span><br></pre></td></tr></table></figure>
<p>找到可执行文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">everettjfs-iPhone:~ root# ps aux | grep /App</span><br><span class="line">mobile   38363   4.4  8.5   776400  88748   ??  Ss    8:55PM   0:52.96 /var/mobile/Containers/Bundle/Application/25FB096A-8122-49B5-9304-5FDB9080D9B0/WeChat.app/WeChat</span><br></pre></td></tr></table></figure>
<p>沙盒路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">everettjfs-iPhone:~ root# cycript -p WeChat</span><br><span class="line">cy# [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask]</span><br><span class="line">@[#&quot;file:///var/mobile/Containers/Data/Application/F36BD1C1-1C39-4C83-AD4B-6D9F2B976330/Documents/&quot;]</span><br></pre></td></tr></table></figure>
<p>砸壳：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">everettjfs-iPhone:~ root# clutch -i</span><br><span class="line">everettjfs-iPhone:~ root# clutch -b com.tencent.xin</span><br><span class="line">Finished dumping com.tencent.xin to /var/tmp/clutch/5F6CA026-C176-4FB0-9569-90F2DD251385</span><br></pre></td></tr></table></figure>
<p>导出头文件：</p>
<p>这里不用class-dump-z 是因为class-dump-z会无法识别UIKit的很多类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[everettjf@e w ]$ class-dump -s -S -H WeChat -o headers</span><br></pre></td></tr></table></figure>
<h1 id="初步窥探"><a href="#初步窥探" class="headerlink" title="初步窥探"></a>初步窥探</h1><h2 id="定位Controller"><a href="#定位Controller" class="headerlink" title="定位Controller"></a>定位Controller</h2><p>打开微信，进入和某个人的会话（也就是这篇文章要研究的“聊天消息界面”）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">everettjfs-iPhone:~ root# cycript -p WeChat</span><br><span class="line">cy# [[[UIWindow keyWindow] rootViewController] _printHierarchy].toString()</span><br><span class="line">&lt;MMTabBarController 0x18265240&gt;, state: appeared, view: &lt;UILayoutContainerView 0x18265ac0&gt;</span><br><span class="line">   | &lt;MMUINavigationController 0x1800f230&gt;, state: appeared, view: &lt;UILayoutContainerView 0x180cd0e0&gt;</span><br><span class="line">   |    | &lt;NewMainFrameViewController 0x179a2400&gt;, state: disappeared, view: &lt;MMUIHookView 0x1827f980&gt; not in the window</span><br><span class="line">   |    | &lt;BaseMsgContentViewController 0x179b3800&gt;, state: appeared, view: &lt;UIView 0x16e36c30&gt;</span><br><span class="line">   | &lt;MMUINavigationController 0x181a40a0&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x181a4400&gt; not in the window</span><br><span class="line">   |    | &lt;ContactsViewController 0x17162800&gt;, state: disappeared, view:  (view not loaded)</span><br><span class="line">   | &lt;MMUINavigationController 0x181adb10&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x181ade00&gt; not in the window</span><br><span class="line">   |    | &lt;FindFriendEntryViewController 0x179aec00&gt;, state: disappeared, view:  (view not loaded)</span><br><span class="line">   | &lt;MMUINavigationController 0x18003e00&gt;, state: disappeared, view: &lt;UILayoutContainerView 0x18008cc0&gt; not in the window</span><br><span class="line">   |    | &lt;MoreViewController 0x179ad400&gt;, state: disappeared, view:  (view not loaded)</span><br></pre></td></tr></table></figure>
<p>微信主界面是个MMTabBarController，有四个TabBarItem，分别对应一个MMUINavigationController。对应的RootViewController如下：</p>
<ul>
<li>微信 NewMainFrameViewController</li>
<li>通讯录 ContactsViewController</li>
<li>发现 FindFriendEntryViewController</li>
<li>我 MoreViewController</li>
</ul>
<p>此次我们关注的“聊天消息界面”，就是BaseMsgContentViewController （state：appeared）。</p>
<h2 id="观察Views"><a href="#观察Views" class="headerlink" title="观察Views"></a>观察Views</h2><h3 id="Reveal"><a href="#Reveal" class="headerlink" title="Reveal"></a>Reveal</h3><p>界面中各种类型的消息都发送一下，这里先发送：文本、图片、位置、语音。<br>使用Reveal观察，如下图：</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1465648981061.png" alt="img"></p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1465649157982.png" alt="img"></p>
<h3 id="MMTableView"><a href="#MMTableView" class="headerlink" title="MMTableView"></a>MMTableView</h3><p>从这两张图可以看到：</p>
<p>整个消息列表本质上是个 MMTableView （这个我们自己实现一般也是这么做）。从class-dump出的头文件中可知道，MMTableView是UITableView的子类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface MMTableView : UITableView &lt;MMDelegateCenterExt&gt;</span><br></pre></td></tr></table></figure>
<p>TableView的Cell只有一种类型， MultiSelectTableViewCell。<strong>这里开始看到时，很让我好奇。为什么没有采用传统的一个消息一个Cell的方式呢</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface MultiSelectTableViewCell : UITableViewCell</span><br></pre></td></tr></table></figure>
<h3 id="MessageNodeView"><a href="#MessageNodeView" class="headerlink" title="MessageNodeView"></a>MessageNodeView</h3><p>Cell都是MultiSelectTableViewCell，而区分不同消息的是contentView的内容。</p>
<ul>
<li>文本消息 ： TextMessageNodeView</li>
<li>图像消息： ImageMessageNodeView</li>
<li>位置消息：LocationMessageNodeView</li>
<li>语音消息：VocieMessageNodeView （上面的截图看不到）</li>
</ul>
<p>此外，消息之间的时间，也是MultiSelectTableViewCell，只是contentView是关于时间的Label。</p>
<h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>弄明白消息UI的基本结构，下一步就是找到如何创建这些MessageNodeView。<strong>这里很容易有个疑问，所有消息都是MultiSelectTableViewCell，那如何实现的Cell重用呢？</strong> 继续探索。</p>
<h2 id="观察Controller"><a href="#观察Controller" class="headerlink" title="观察Controller"></a>观察Controller</h2><p>在class-dump出的头文件中找到 BaseMsgContentViewController类。可以找到 BaseMsgContentViewController.h文件，这个头文件有614行，可见这个类的复杂。（估计微信开发早期并没有考虑到后期的大量需求加入，于是成了今天的Mess View Controller）</p>
<p>这里细化此次行动的目的：想知道聊天中的每一条消息是如何创建、显示的。</p>
<p>观察类的实现，发现一些相关变量和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// 字面上看，应该就是存储MessageNode的数组</span><br><span class="line">NSMutableArray *m_arrMessageNodeData;</span><br><span class="line">// 应该是存储所有支持的MessageNode Class类型</span><br><span class="line">struct vector&lt;Class, std::__1::allocator&lt;Class&gt;&gt; m_messageNodeClass;</span><br><span class="line">// 这就是主要是TableView</span><br><span class="line">MMTableView *m_tableView;</span><br><span class="line"></span><br><span class="line">// 预创建消息，有意思，一会儿仔细研究研究</span><br><span class="line">- (void)preCreateMessageContentNode:(id)arg1;</span><br><span class="line">- (void)preCreateMessageSplitNode:(id)arg1;</span><br><span class="line">- (void)preCreateMessageTimeNode:(id)arg1;</span><br><span class="line"></span><br><span class="line">// 初始化Class</span><br><span class="line">- (void)initMessageNodeClass;</span><br><span class="line">- (id)newMessageNodeViewForMessageWrap:(id)arg1 contact:(id)arg2 chatContact:(id)arg3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取node数目</span><br><span class="line">- (unsigned int)getMsgNodeCount;</span><br><span class="line">// 获取指定索引的node</span><br><span class="line">- (id)getNodeDataByIndex:(unsigned int)arg1;</span><br><span class="line">// 获取消息node数组</span><br><span class="line">- (id)GetMessageNodeDataArray;</span><br><span class="line"></span><br><span class="line">// 添加</span><br><span class="line">- (void)addMessageNode:(id)arg1 layout:(BOOL)arg2 addMoreMsg:(BOOL)arg3;</span><br><span class="line">- (void)addReceiveMessageNode:(id)arg1;</span><br><span class="line">- (id)addSplitNode:(id)arg1 addMoreMsg:(BOOL)arg2;</span><br><span class="line">- (void)addTimeNode:(id)arg1 layout:(BOOL)arg2 addMoreMsg:(BOOL)arg3;</span><br><span class="line">// 移除</span><br><span class="line">- (void)removeAllObjectsFromMessageNodeDatas;</span><br><span class="line">- (void)removeObjectsFromMessageNodeDatas:(id)arg1;</span><br><span class="line">// 更新</span><br><span class="line">- (void)updateMessageNodeImageLoadingPercent:(unsigned long)arg1 percent:(unsigned long)arg2;</span><br><span class="line">- (void)updateMessageNodeStatus:(id)arg1;</span><br><span class="line">- (void)updateMessageNodeViewForOrientation:(id)arg1;</span><br><span class="line"></span><br><span class="line">// 一些NodeView的事件</span><br><span class="line">- (void)tagLink:(id)arg1 messageWrap:(id)arg2;</span><br><span class="line">- (void)tapAppNodeView:(id)arg1;</span><br><span class="line">- (void)tapFriendCard_NodeView:(id)arg1 WithContact:(id)arg2 WithMsg:(id)arg3;</span><br><span class="line">- (void)tapImage_NodeView:(id)arg1;</span><br><span class="line">- (void)tapLocation_NodeView:(id)arg1;</span><br><span class="line">- (void)tapPushContact_NodeView:(id)arg1;</span><br><span class="line">- (void)tapPushMail_NodeView:(id)arg1 withPushMailWrap:(id)arg2;</span><br><span class="line">- (void)tapReader_NodeView:(id)arg1;</span><br><span class="line">- (void)tapStatus_NodeView:(id)arg1;</span><br><span class="line">- (void)tapText_NodeView:(id)arg1;</span><br><span class="line">- (void)tapVideoStatus_NodeView:(id)arg1;</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableArray-m-arrMessageNodeData"><a href="#NSMutableArray-m-arrMessageNodeData" class="headerlink" title="NSMutableArray *m_arrMessageNodeData;"></a>NSMutableArray *m_arrMessageNodeData;</h3><p>cycript 打印出来</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cy# v = #0x15067600</span><br><span class="line">#&quot;&lt;BaseMsgContentViewController: 0x15067600&gt;&quot;</span><br><span class="line">cy# v-&gt;m_arrMessageNodeData</span><br><span class="line">@[#&quot;&lt;CMessageNodeData: 0x15b95260&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15adf260&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15a4abb0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x1580f190&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15a49930&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x1589b8a0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15a41410&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x158783e0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15a4a3b0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15aa14f0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x1475ce50&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15bf9960&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15b53f40&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x147ad9f0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15b6d240&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15ba04b0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15b90050&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15be7ba0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15b84eb0&gt;&quot;]</span><br><span class="line">cy# v-&gt;m_arrMessageNodeData.count</span><br><span class="line">19</span><br></pre></td></tr></table></figure>
<p><em>前提，与对方的聊天消息已经有很多条</em>，首次打开与对方的聊天消息界面，可以看到微信默认只加载19条消息。</p>
<p>CMessageNodeData是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@interface CMessageNodeData : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    int m_eMsgNodeType;</span><br><span class="line">    CMessageWrap *m_msgWrap;</span><br><span class="line">    UIView *m_view;</span><br><span class="line">    unsigned long m_uCreateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，这里有个UIView</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@interface CMessageWrap : MMObject &lt;IAppMsgPathMgr, ISysNewXmlMsgExtendOperation, IMsgExtendOperation, NSCopying&gt;</span><br><span class="line">&#123;</span><br><span class="line">    BOOL m_bIsSplit;</span><br><span class="line">    BOOL m_bNew;</span><br><span class="line">    unsigned long m_uiMesLocalID;</span><br><span class="line">    long long m_n64MesSvrID;</span><br><span class="line">    NSString *m_nsFromUsr;</span><br><span class="line">    NSString *m_nsToUsr;</span><br><span class="line">    unsigned long m_uiMessageType;</span><br><span class="line">    NSString *m_nsContent;</span><br><span class="line">    unsigned long m_uiStatus;</span><br><span class="line">    unsigned long m_uiImgStatus;</span><br><span class="line">    //.............省略大量字段.............</span><br></pre></td></tr></table></figure>
<p>CMessageWrap自然就是对消息数据的封装。</p>
<p>CMessageNodeData有个UIView *m_view的变量，看看是什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y# d = v-&gt;m_arrMessageNodeData</span><br><span class="line">@[#&quot;&lt;CMessageNodeData: 0x15b95260&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15adf260&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x15a4abb0&gt;&quot;,#&quot;&lt;CMessageNodeData: 0x1580f190&gt;&quot;,#&quot; </span><br><span class="line">.....省略....</span><br><span class="line">cy# var x = []; for(var i = 0; i &lt; d.count;i++) x.push([d objectAtIndex:i].m_view); x</span><br><span class="line">[#&quot;&lt;UIView: 0x1592f9c0; frame = (0 10; 320 28); layer = &lt;CALayer: 0x147e6cc0&gt;&gt;&quot;,#&quot;&lt;TextMessageNodeView: 0x1582cca0; frame = (251 0; 60 59); layer = &lt;CALayer: 0x158b1350&gt;&gt;&quot;,#&quot;&lt;TextMessageNodeView: 0x15a58d60; frame = (251 0; 60 59); layer = &lt;CALayer: 0x15a3cdf0&gt;&gt;&quot;,#&quot;&lt;TextMessageNodeView: 0x15a3ba10; frame = (251 0; 60 59); layer = &lt;CALayer: 0x15ab9ab0&gt;&gt;&quot;,#&quot;&lt;TextMessageNodeView: 0x15a31610; frame = (251 0; 60 59); layer = &lt;CALayer: 0x15a31760&gt;&gt;&quot;,#&quot;&lt;TextMessageNodeView: 0x15a57dc0; frame = (251 0; 60 59); layer = &lt;CALayer: 0x15a547b0</span><br><span class="line">.....省略.......</span><br><span class="line">odeView: 0x159ee260; frame = (186 0; 125 59); layer = &lt;CALayer: 0x159ee3b0&gt;&gt;&quot;,#&quot;&lt;ImageMessageNodeView: 0x15b91cd0; frame = (179.5 0; 131.5 150); layer = &lt;CALayer: 0x15b6e8e0&gt;&gt;&quot;,#&quot;&lt;UIView: 0x15b675d0; frame = (0 10; 320 28); layer = &lt;CALayer: 0x15be5fa0&gt;&gt;&quot;,#&quot;&lt;LocationMessageNodeView: 0x15bdaee0; frame = (50 0; 261 139); layer = &lt;CALayer: 0x15b7d290&gt;&gt;&quot;,#&quot;&lt;TextMessageNodeView: 0x15bbf400; frame = (144 0; 167 59); layer = &lt;CALayer: 0x15be6770&gt;&gt;&quot;]</span><br></pre></td></tr></table></figure>
<p>可见，m_view就是MultiSelectTableViewCell的contentView下的那个UIView。</p>
<p><strong>这里又有疑问：屏幕上显示的Cell其实就4个，为什么这些 CMessageNodeData中的m_view都有值（不是nil），难道没有实现重用？是的，目前我发现，确实没有实现重用。</strong></p>
<p>为验证，我随便发送了几百条各种消息，再输出所有的m_view。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> cy# d.count</span><br><span class="line">419</span><br><span class="line">cy# var x = []; for(var i = 0; i &lt; d.count;i++) x.push([d objectAtIndex:i].m_view); x</span><br><span class="line">[#&quot;&lt;UIView: 0x15c91540; frame = (0 10; 320 28); layer = &lt;CALayer: 0x16096bb0&gt;&gt;&quot;,#&quot;&lt;AppUrlMessageNodeView: 0x160977e0; frame = (0 0; 327 149); layer = &lt;CALayer: 0x16098f50&gt;&gt;&quot;,#&quot;&lt;UIView: 0x16098d70; frame = (0 10; 320 28); layer = &lt;CALayer: 0x16099bd0&gt;&gt;&quot;,#&quot;&lt;ImageMessageNodeView: 0x1609b000; frame = (179.5 0; 131.5 150); layer = &lt;CALayer: 0x1609a840&gt;&gt;&quot;,#&quot;&lt;ImageMessageNodeView: 0x160a3d80; frame = (</span><br><span class="line">// ........省略..................</span><br><span class="line">cy# x.length</span><br><span class="line">419</span><br></pre></td></tr></table></figure>
<p> 好吧，果然419个m_view都不是nil。</p>
<p><strong>我的天呐，这怎么能行。不过观察下内存占用，以及再仔细想想，这种方案还是可以接受的。详细见下文。</strong></p>
<p>我想到的原因如下：</p>
<ul>
<li>内存占用并不会太多（具体数据见下文）。</li>
<li>聊天界面出现太多m_view的情形并不多。且出现时由于内存占用可接受，就无所谓了。</li>
</ul>
<h3 id="struct-vector"><a href="#struct-vector" class="headerlink" title="struct vector"></a>struct vector<class, std::__1::allocator<class="">&gt; m_messageNodeClass;</class,></h3><p>这里能看出BaseMsgContentViewController的实现文件是 BaseMsgContentViewController.mm，也就是Objective C++写的。</p>
<p>m_messageNodeClass与下面的方法有关：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)initMessageNodeClass;</span><br></pre></td></tr></table></figure></p>
<p>使用Hopper反编译WeChat的二进制文件：</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1465664951065.png" alt="img"></p>
<p>再反汇编为c代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">void -[BaseMsgContentViewController initMessageNodeClass](void * self, void * _cmd) &#123;</span><br><span class="line">    r7 = &amp;arg_C;</span><br><span class="line">    sp = sp - 0xb4;</span><br><span class="line">    r11 = self;</span><br><span class="line">    r6 = *objc_ivar_offset_BaseMsgContentViewController_m_messageNodeClass;</span><br><span class="line">    r5 = *(r11 + r6);</span><br><span class="line">    r0 = *(r11 + 0xa4);</span><br><span class="line">    if (r0 != r5) &#123;</span><br><span class="line">            do &#123;</span><br><span class="line">                    *(r11 + 0xa4) = r0 - 0x4;</span><br><span class="line">                    r0 = *(r0 + 0xfffffffffffffffc);</span><br><span class="line">                    [r0 release];</span><br><span class="line">                    r0 = *(r11 + 0xa4);</span><br><span class="line">            &#125; while (r0 != r5);</span><br><span class="line">            r6 = *objc_ivar_offset_BaseMsgContentViewController_m_messageNodeClass;</span><br><span class="line">    &#125;</span><br><span class="line">    r8 = @selector(class);</span><br><span class="line">    r0 = [MultiColumnReaderMessageNodeView class];</span><br><span class="line">    r7 = r7;</span><br><span class="line">    r0 = [r0 retain];</span><br><span class="line">    r1 = r6 + 0x4;</span><br><span class="line">    arg_B0 = r0;</span><br><span class="line">    r2 = r6 + r11;</span><br><span class="line">    r3 = *(r11 + r1);</span><br><span class="line">    if (r3 &lt; *(r2 + 0x8)) &#123;</span><br><span class="line">            arg_B0 = 0x0;</span><br><span class="line">            *r3 = r0;</span><br><span class="line">            *(r11 + r1) = *(r11 + r1) + 0x4;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">            void std::__1::vector&lt;objc_class* __strong, std::__1::allocator&lt;objc_class* __strong&gt; &gt;::__push_back_slow_path&lt;objc_class* __strong&gt;();</span><br><span class="line">            [arg_B0 release];</span><br><span class="line">    &#125;</span><br><span class="line">    r4 = *objc_ivar_offset_BaseMsgContentViewController_m_messageNodeClass;</span><br><span class="line">    r0 = [ImageTextReaderMessageNodeView class];</span><br><span class="line">	//.....省略......</span><br></pre></td></tr></table></figure>
<p>就是把所有支持的MessageNode的Class都push_back到这个vector中。</p>
<p><strong>这里能看到微信支持的所有可显示的消息类型</strong></p>
<p>手动整理伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;Class&gt; m_messageNodeClass;</span><br><span class="line">m_messageNodeClass.push_back([MultiColumnReaderMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([ImageTextReaderMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([HeadImgReaderMessageNodeaView class]);</span><br><span class="line">m_messageNodeClass.push_back([MessageSysNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AttributedReaderMessageNodeaView class]);</span><br><span class="line">m_messageNodeClass.push_back([ReaderNewMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([MultiReaderMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([MailMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([MassSendMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([ImageMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([VoiceMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([ShortVideoMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([VideoMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([ShareCardMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([EmoticonMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([GameMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([VoipContentNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppTextMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppImageMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppEmoticonMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppFileMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppUrlMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppShakeMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([VoiceReminderConfirmNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([VoiceReminderRemindNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppProductMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppEmoticonSharedMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppWCProductMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppWCCardMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppTVMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppTrackRoomMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppRecordMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppNoteMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppHardWareRankMessageNode class]);</span><br><span class="line">m_messageNodeClass.push_back([AppHardWareLikeNotifyMessageNode class]);</span><br><span class="line">m_messageNodeClass.push_back([MultiTalkMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([WCPayTransferMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([WCPayTransferAcceptedMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([WCPayTransferRejectedMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([WCPayMessageBaseNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([WCPayC2CMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([WCPayC2CFestivalMsgNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([AppDefaultMessageNodeView class]);</span><br><span class="line">m_messageNodeClass.push_back([TextMessageNodeView class]);</span><br></pre></td></tr></table></figure>
<p>可见，微信真实个巨大的工程，支持的消息类型这么多（我使用的微信版本：6.3.19）。</p>
<p>随便看个消息，例如：<br>MessageSysNodeView<br>继承自 BaseMessageNodeView 然后 MMUIView</p>
<h3 id="void-preCreateMessageXXXXNode"><a href="#void-preCreateMessageXXXXNode" class="headerlink" title="- (void) preCreateMessageXXXXNode"></a>- (void) preCreateMessageXXXXNode</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)preCreateMessageContentNode:(id)arg1;</span><br><span class="line">- (void)preCreateMessageSplitNode:(id)arg1;</span><br><span class="line">- (void)preCreateMessageTimeNode:(id)arg1;</span><br></pre></td></tr></table></figure>
<p>由这三个preCreateMessage开头的方法，可猜测到 MultiSelectTableViewCell的contentView的第一层子View 存在三类：</p>
<ul>
<li>具体内容ContentNode</li>
<li>分隔符Node</li>
<li>时间Node</li>
</ul>
<p>Hopper反汇编找到对应代码：</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1465666569528.png" alt="img"></p>
<h4 id="TimeNode"><a href="#TimeNode" class="headerlink" title="TimeNode"></a>TimeNode</h4><p>为循序渐进，先研究下TimeNode的preCreate：</p>
<p>由于内部有取arg2.m_view的代码，能基本猜到 arg2是 CMessageNodeData类型。（后面可以用lldb证实）</p>
<p>关键代码行及伪代码大概如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void -[BaseMsgContentViewController preCreateMessageTimeNode:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">messageNodeData = arg2</span><br><span class="line">if(messageNodeData.m_view == nil)&#123;</span><br><span class="line">	// 就是填充m_view</span><br><span class="line">	</span><br><span class="line">	// 从MMThemeManager获取时间Node的高度</span><br><span class="line">    r5 = [[MMThemeManager sharedThemeManager] retain];</span><br><span class="line">    [[r5 getValueOfProperty:@&quot;message_node_timeNode_height&quot; inRuleSet:@&quot;#message_node_view&quot;] retain];</span><br><span class="line">     </span><br><span class="line">	UIView *timeRoot = [][UIView alloc]initWithFrame:....];</span><br><span class="line">    </span><br><span class="line">    r11 = [[MMUILabel alloc] init];</span><br><span class="line">	// 这是label各种属性</span><br><span class="line">	</span><br><span class="line">	r10 = [[UIImageView alloc] init];</span><br><span class="line">	// 设置ImageView各种属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终就是构成这个：</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1465836652040.png" alt="img"></p>
<h4 id="ContentNode"><a href="#ContentNode" class="headerlink" title="ContentNode"></a>ContentNode</h4><p>知道了TimeNode如何preCreate的，那ContentNode就类似了，只是代码更多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void -[BaseMsgContentViewController preCreateMessageContentNode:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line"></span><br><span class="line">messageNodeData = arg2</span><br><span class="line">if(messageNodeData.m_view == nil)&#123;</span><br><span class="line">	// 仍然是填充m_view</span><br><span class="line"></span><br><span class="line">	// 判断是否自己发的消息</span><br><span class="line">    r5 = [[r11 m_msgWrap] retain];</span><br><span class="line">    arg_14 = [CMessageWrap isSenderFromMsgWrap:r5];</span><br><span class="line">    </span><br><span class="line">	如果是对方消息</span><br><span class="line">	r0 = [r8 newMessageNodeViewForMessageWrap:r4 contact:r5 chatContact:STK-1];</span><br><span class="line">	如果是我发送的消息</span><br><span class="line">	r0 = [r8 newMessageNodeViewForMessageWrap:r6 contact:0x0 chatContact:STK-1];</span><br><span class="line"></span><br><span class="line">	设置m_view</span><br><span class="line"></span><br><span class="line">	//计算frame</span><br><span class="line"></span><br><span class="line">	//GameNode特殊处理</span><br><span class="line">	//语音特殊处理	r2 = [VoiceMessageNodeView class];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS:这个方法之前的版本很长，现在的版本进行了优化。新增了newMessageNodeViewForMessageWrap方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void * -[BaseMsgContentViewController newMessageNodeViewForMessageWrap:contact:chatContact:](void * self, void * _cmd, void * arg2, void * arg3, void * arg4) &#123;</span><br><span class="line">	</span><br><span class="line">	// 这里循环判断vector中的每个类，交给每个类判断是否是自己的类型</span><br><span class="line">    r0 = r5-&gt;m_messageNodeClass;</span><br><span class="line">	</span><br><span class="line">	for(Class in r0)&#123;</span><br><span class="line"></span><br><span class="line">	// 先判断能否创建</span><br><span class="line">    r4 = *(r0 + r11 * 0x4);</span><br><span class="line">    if (([r4 canCreateMessageNodeViewInstanceWithMessageWrap: r2] &amp; 0xff) != 0x0) goto loc_1609718;</span><br><span class="line"></span><br><span class="line">	// 创建</span><br><span class="line">    r0 = [r4 alloc];</span><br><span class="line">    r4 = arg_8;</span><br><span class="line">    r6 = arg_4;</span><br><span class="line">    var_0 = r6;</span><br><span class="line">    r5 = [r0 initWithMessageWrap:arg_C Contact:r4 ChatContact:STK-1];</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="canCreateMessageNodeViewInstanceWithMessageWrap"><a href="#canCreateMessageNodeViewInstanceWithMessageWrap" class="headerlink" title="canCreateMessageNodeViewInstanceWithMessageWrap"></a>canCreateMessageNodeViewInstanceWithMessageWrap</h4><p>看下canCreateMessageNodeViewInstanceWithMessageWrap方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char +[BaseMessageNodeView canCreateMessageNodeViewInstanceWithMessageWrap:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">    return 0x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看所有NodeView的基类 BaseMessageNodeView，默认返回0x0，也就是NO。（32位下BOOL是char，这里也就是返回个BOOL类型）</p>
<p>再随便找个子NodeView类，例如：MessageSysNodeView</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">char +[MessageSysNodeView canCreateMessageNodeViewInstanceWithMessageWrap:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">    r4 = [arg2 retain];</span><br><span class="line">    r5 = @selector(m_uiMessageType);</span><br><span class="line">    if ([r4 m_uiMessageType] == 0x2710) &#123;</span><br><span class="line">            r5 = 0x1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">            r0 = [r4 m_uiMessageType];</span><br><span class="line">            r5 = 0x0;</span><br><span class="line">            asm&#123; it         eq &#125;;</span><br><span class="line">            if (r0 == 0x2712) &#123;</span><br><span class="line">                    r5 = 0x1;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [r4 release];</span><br><span class="line">    r0 = r5;</span><br><span class="line">    return r0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见。如果 m_uiMessageType（CMessageNodeData的CMessageWrap的成员）是 0x2710或0x2712，则认为是此消息类型。</p>
<p>再看ImageMessageNodeView：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">char +[ImageMessageNodeView canCreateMessageNodeViewInstanceWithMessageWrap:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">    r4 = [arg2 retain];</span><br><span class="line">    r5 = @selector(m_uiMessageType);</span><br><span class="line">    if (([r4 m_uiMessageType] == 0x3) || ([r4 m_uiMessageType] == 0xd)) &#123;</span><br><span class="line">            r5 = 0x1;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">            r0 = [r4 m_uiMessageType];</span><br><span class="line">            r5 = 0x0;</span><br><span class="line">            asm&#123; it         eq &#125;;</span><br><span class="line">            if (r0 == 0x27) &#123;</span><br><span class="line">                    r5 = 0x1;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [r4 release];</span><br><span class="line">    r0 = r5;</span><br><span class="line">    return r0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可知 0x3、0xd、0x27 都是图像。</p>
<p>还有很多消息，不一一列出了。</p>
<p>最后再看下 TextMessageNodeView：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char +[TextMessageNodeView canCreateMessageNodeViewInstanceWithMessageWrap:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">    return 0x1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接返回的YES。可见，如果所有消息都不是的话，则按照文本消息来处理。TextMessageNodeView也正好是最后一个push_back到 m_messageNodeClass中去的。</p>
<h4 id="initWithMessageWrap"><a href="#initWithMessageWrap" class="headerlink" title="initWithMessageWrap"></a>initWithMessageWrap</h4><p>先看BaseMessageNodeView：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void * -[BaseMessageNodeView initWithMessageWrap:Contact:ChatContact:](void * self, void * _cmd, void * arg2, void * arg3, void * arg4) &#123;</span><br><span class="line">	省略……</span><br></pre></td></tr></table></figure>
<p>再看看TextMessageNodeView  的initWithMessageWrap:Contact:ChatContact。<br>代码或多或少，没有什么关键代码。</p>
<p>就是根据CMessageWrap配置各种View的属性。</p>
<h1 id="继续研究"><a href="#继续研究" class="headerlink" title="继续研究"></a>继续研究</h1><p>下面想办法找到preCreate调用源。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>usbmuxd</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  python-client python tcprelay.py -t 22:2222 1234:1234</span><br><span class="line">Forwarding local port 2222 to remote port 22</span><br><span class="line">Forwarding local port 1234 to remote port 1234</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>ssh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@localhost -p 2222</span><br></pre></td></tr></table></figure>
<p>debugserver</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">everettjfs-iPhone:~ root# debugserver *:1234 -a WeChat</span><br><span class="line">debugserver-@(#)PROGRAM:debugserver  PROJECT:debugserver-320.2.89</span><br><span class="line"> for armv7.</span><br><span class="line">Attaching to process WeChat...</span><br><span class="line">Listening to port 1234 for a connection from *...</span><br><span class="line">Waiting for debugger instructions for process 0.</span><br></pre></td></tr></table></figure>
<p>lldb</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[everettjf@e ~ ]$ lldb</span><br><span class="line">(lldb) process connect connect://localhost:1234</span><br><span class="line">Process 67776 stopped</span><br><span class="line">* thread #1: tid = 0x214590, 0x31ef4474 libsystem_kernel.dylib`mach_msg_trap + 20, queue = &apos;com.apple.main-thread&apos;, stop reason = signal SIGSTOP</span><br><span class="line">    frame #0: 0x31ef4474 libsystem_kernel.dylib`mach_msg_trap + 20</span><br><span class="line">libsystem_kernel.dylib`mach_msg_trap:</span><br><span class="line">-&gt;  0x31ef4474 &lt;+20&gt;: pop    &#123;r4, r5, r6, r8&#125;</span><br><span class="line">    0x31ef4478 &lt;+24&gt;: bx     lr</span><br><span class="line"></span><br><span class="line">libsystem_kernel.dylib`mach_msg_overwrite_trap:</span><br><span class="line">    0x31ef447c &lt;+0&gt;:  mov    r12, sp</span><br><span class="line">    0x31ef4480 &lt;+4&gt;:  push   &#123;r4, r5, r6, r8&#125;</span><br></pre></td></tr></table></figure>
<p>找到偏移地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) image list -o -f</span><br><span class="line">[  0] 0x000e7000 /private/var/mobile/Containers/Bundle/Application/25FB096A-8122-49B5-9304-5FDB9080D9B0/WeChat.app/WeChat(0x00000000000eb000)</span><br><span class="line">[  1] 0x031c7000 /Library/MobileSubstrate/MobileSubstrate.dylib(0x00000000031c7000)</span><br></pre></td></tr></table></figure>
<p>看到image list -o -f后面的偏移地址：0x000e7000</p>
<h2 id="历史消息"><a href="#历史消息" class="headerlink" title="历史消息"></a>历史消息</h2><p>先看下聊天消息界面时默认加载的历史消息。</p>
<p>hopper中找到BaseMsgContentViewController::preCreateMessageContentNode:  的文件偏移地址：0x0160a444<br><img src="https://everettjf.github.io/stuff/eimkit/1465992949249.png" alt="img"></p>
<p>计算出真实偏移地址（我比较喜欢拿ipython当计算器）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [1]: hex(0x000e7000+0x0160a444)</span><br><span class="line">Out[1]: &apos;0x16f1444&apos;</span><br></pre></td></tr></table></figure>
<p>下断点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x16f1444</span><br><span class="line">Breakpoint 1: where = WeChat`___lldb_unnamed_function80337$$WeChat, address = 0x016f1444</span><br></pre></td></tr></table></figure>
<p>然后点击一个会话，进入消息界面。此时会命中断点。</p>
<p>这里既然命中断点了，顺带看一下 preCreateMessageContentNode 的参数类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $r0</span><br><span class="line">&lt;BaseMsgContentViewController: 0x17127c00&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po (char*)$r1</span><br><span class="line">&quot;preCreateMessageContentNode:&quot;</span><br><span class="line"></span><br><span class="line">(lldb) po $r2</span><br><span class="line">&lt;CMessageNodeData: 0x1789bfb0&gt;</span><br></pre></td></tr></table></figure>
<p>回归正题，bt命令查看调用栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) bt</span><br><span class="line">* thread #1: tid = 0x214590, 0x016f1444 WeChat`___lldb_unnamed_function80337$$WeChat, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 1.1</span><br><span class="line">  * frame #0: 0x016f1444 WeChat`___lldb_unnamed_function80337$$WeChat</span><br><span class="line">    frame #1: 0x016f2516 WeChat`___lldb_unnamed_function80343$$WeChat + 990</span><br><span class="line">    frame #2: 0x016f2bfe WeChat`___lldb_unnamed_function80345$$WeChat + 590</span><br><span class="line">    frame #3: 0x016f397e WeChat`___lldb_unnamed_function80355$$WeChat + 690</span><br><span class="line">    frame #4: 0x01708ac0 WeChat`___lldb_unnamed_function80565$$WeChat + 1416</span><br><span class="line">    frame #5: 0x26c54b8e UIKit`-[UIViewController loadViewIfRequired] + 602</span><br><span class="line">    frame #6: 0x26c548fc UIKit`-[UIViewController view] + 24</span><br><span class="line">    省略</span><br></pre></td></tr></table></figure>
<p>可见这几个方法都是在主线程调用。frame#0就是preCreateMessageContentNode方法。frame #1就是调用preCreateMessageContentNode的方法。我们找下frame#1的方法。<br>从内存地址 0x016f2516 减去 偏移地址0x000e7000 就得到文件偏移地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [4]: hex(0x016f2516-0x000e7000)</span><br><span class="line">Out[4]: &apos;0x160b516&apos;</span><br></pre></td></tr></table></figure>
<p>hopper 中找到这个方法：<br><img src="https://everettjf.github.io/stuff/eimkit/1466097350949.png" alt="img"></p>
<p>找到方法：<br><img src="https://everettjf.github.io/stuff/eimkit/1466097381889.png" alt="img"></p>
<p>就是这个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void -[BaseMsgContentViewController addMessageNode:layout:addMoreMsg:](void * self, void * _cmd, void * arg2, char arg3, char arg4) &#123;</span><br></pre></td></tr></table></figure>
<p>下断点到这个方法的首地址 0x16f2138 = 0x000e7000 + 0x0160b138：（先清掉之前的断点）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [6]: hex(0x000e7000 + 0x0160b138)</span><br><span class="line">Out[6]: &apos;0x16f2138&apos;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br l</span><br><span class="line">Current breakpoints:</span><br><span class="line">1: address = WeChat[0x0160a444], locations = 1, resolved = 1, hit count = 1</span><br><span class="line">  1.1: where = WeChat`___lldb_unnamed_function80337$$WeChat, address = 0x016f1444, resolved, hit count = 1</span><br><span class="line">(lldb) br delete 1</span><br><span class="line">1 breakpoints deleted; 0 breakpoint locations disabled.</span><br><span class="line"></span><br><span class="line">(lldb) br s -a 0x16f2138</span><br><span class="line">Breakpoint 3: where = WeChat`___lldb_unnamed_function80343$$WeChat, address = 0x016f2138</span><br></pre></td></tr></table></figure>
<p>看下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $r0</span><br><span class="line">&lt;BaseMsgContentViewController: 0x17127c00&gt;</span><br><span class="line">(lldb) po (char*)$r1</span><br><span class="line">&quot;addMessageNode:layout:addMoreMsg:&quot;</span><br><span class="line">(lldb) po $r2</span><br><span class="line">&#123;m_uiMesLocalID=384, m_ui64MesSvrID=7606243121581773106, m_nsFromUsr=wxi*h12~19, m_nsToUsr=wxi*t21~19, m_uiStatus=2, type=1, msgSource=&quot;(null)&quot;&#125;</span><br><span class="line">(lldb) po [$r2 class]</span><br><span class="line">CMessageWrap</span><br><span class="line">(lldb) p $r3</span><br><span class="line">(unsigned int) $13 = 0</span><br><span class="line">(lldb) p $r4</span><br><span class="line">(unsigned int) $14 = 40</span><br></pre></td></tr></table></figure>
<p>也就是 BaseMsgContentViewController addMessageNode:layout:addMoreMsg 方法的第一个参数是 CMessageWrap，layout是0 , addMoreMsg 是40 。</p>
<p>同样的步骤，看下调用栈中的剩余几个方法，汇总到一起就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void -[BaseMsgContentViewController preCreateMessageContentNode:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">void -[BaseMsgContentViewController addMessageNode:layout:addMoreMsg:](void * self, void * _cmd, void * arg2, char arg3, char arg4) &#123;</span><br><span class="line">void -[BaseMsgContentViewController initHistroyMessageNodeData](void * self, void * _cmd) &#123;</span><br><span class="line">void -[BaseMsgContentViewController initData](void * self, void * _cmd) &#123;</span><br><span class="line">void -[BaseMsgContentViewController viewDidLoad](void * self, void * _cmd) &#123;</span><br></pre></td></tr></table></figure>
<p>利用hopper的反汇编看下这几个方法，我们又找到了，initView等一系列init开头的函数。比如：initTableView 中初始化tableView，并调用了reloadData。（initData在先，initView在后）</p>
<h2 id="历史消息来源"><a href="#历史消息来源" class="headerlink" title="历史消息来源"></a>历史消息来源</h2><p>仔细看 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void -[BaseMsgContentViewController initHistroyMessageNodeData](void * self, void * _cmd) &#123;</span><br><span class="line">...</span><br><span class="line">            arg_1C = r8;</span><br><span class="line">            r0 = [r5 GetMessageArray];</span><br><span class="line">            r7 = r7;</span><br></pre></td></tr></table></figure>
<p>找到 [r5 GetMessageArray] 这句的汇编代码行 0x0160bb20。</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1466104472059.png" alt="img"></p>
<p>断点到这行，然后输出$r0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x163db20 （这里我换了机器，重新启动了Weixin，内存偏移变为0x00032000，因此hex(0x0160BB20 + 0x00032000)=0x163db20）</span><br><span class="line">(lldb) po $r0</span><br><span class="line">&lt;WeixinContentLogicController: 0x1582ad20&gt;</span><br><span class="line">(lldb) po (char*)$r1</span><br><span class="line">&quot;GetMessageArray&quot;</span><br><span class="line">(lldb) n</span><br><span class="line">省略</span><br><span class="line">(lldb) po $r0</span><br><span class="line">&lt;__NSArrayM 0x1584bf30&gt;(</span><br><span class="line">&#123;m_uiMesLocalID=382, m_ui64MesSvrID=4946812604026242266, m_nsFromUsr=wxi*h12~19, m_nsToUsr=wxi*t21~19, m_uiStatus=2, type=1, msgSource=&quot;(null)&quot;&#125; ,</span><br><span class="line">&#123;m_uiMesLocalID=383, m_ui64MesSvrID=145730894416135475, m_nsFromUsr=wxi*h12~19, m_nsToUsr=wxi*t21~19, m_uiStatus=2, type=1, msgSource=&quot;(null)&quot;&#125; ,</span><br><span class="line">省略</span><br><span class="line">)</span><br><span class="line">(lldb) po [[$r0 firstObject]class]</span><br><span class="line">CMessageWrap</span><br></pre></td></tr></table></figure>
<p>单步执行后，也可以看返回值$r0，也就是所有消息CMessageWrap。</p>
<p>可知是WeixinContentLogicController类， 看下这个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface WeixinContentLogicController : BaseMsgContentLogicController</span><br></pre></td></tr></table></figure>
<p>hopper看下WeixinContentLogicController的GetMessageArray方法，发现找不到。那就是在父类BaseMsgContentLogicController中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- BaseMsgContentLogicController GetMessageArray</span><br></pre></td></tr></table></figure>
<p>内部又调用了 WeixinContentLogicController GetMsg:FromID:Limit:LeftCount:LeftUnreadCount:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- WeixinContentLogicController GetMsg:FromID:Limit:LeftCount:LeftUnreadCount:</span><br><span class="line"></span><br><span class="line">    r0 = [MMServiceCenter defaultCenter];</span><br><span class="line">    arg_30 = 0xffffffff;</span><br><span class="line">    r0 = [r0 retain];</span><br><span class="line">    arg_24 = r0;</span><br><span class="line">    arg_30 = 0x2;</span><br><span class="line">    r2 = [CMessageMgr class];</span><br><span class="line">    arg_30 = 0x3;</span><br><span class="line">    r0 = [arg_24 getService:r2];</span><br><span class="line">    arg_30 = 0xffffffff;</span><br><span class="line">    arg_28 = [r0 retain];</span><br><span class="line">    [arg_24 release];</span><br><span class="line">    arg_30 = 0x4;</span><br><span class="line">    asm&#123; stm.w      sp, &#123;r3, r5, r6&#125; &#125;;</span><br><span class="line">    r0 = [arg_28 GetMsgByCreateTime:arg_20 FromID:arg_1C FromCreateTime:STK1 Limit:STK0 LeftCount:STK-1];</span><br></pre></td></tr></table></figure>
<p>大概就是 从 MMServiceCenter 获取到CMessageMgr，然后调用 CMessageMgr的GetMsgByCreateTime:arg_20 FromID:arg_1C FromCreateTime:STK1 Limit:STK0 LeftCount:STK-1 方法。</p>
<p>有两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (id)GetMsgByCreateTime:(id)arg1 FromID:(unsigned long)arg2 FromCreateTime:(unsigned long)arg3 Limit:(unsigned long)arg4 LeftCount:(unsigned int *)arg5;</span><br><span class="line">- (id)GetMsgByCreateTime:(id)arg1 FromID:(unsigned long)arg2 FromCreateTime:(unsigned long)arg3 Limit:(unsigned long)arg4 LeftCount:(unsigned int *)arg5 FromSequence:(unsigned long)arg6;</span><br></pre></td></tr></table></figure>
<p>第一个会调用第二个带FromSequence的方法，hopper看下第二个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">r0 = *objc_ivar_offset_CMessageMgr_m_oMsgDB;</span><br><span class="line">  r2 = *(r7 + 0x14);</span><br><span class="line">  r0 = *(r6 + r0);</span><br><span class="line">  arg_C = r2;</span><br><span class="line">  arg_4 = r5 + 0x5;</span><br><span class="line">  r5 = *(r7 + 0x10);</span><br><span class="line">  arg_8 = r5;</span><br><span class="line">  var_0 = r8;</span><br><span class="line">  r0 = [r0 GetMsgByCreateTime:r10 FromID:arg_24 FromCreateTime:STK2 Limit:STK1 LeftCount:STK0 FromSequence:STK-1];</span><br><span class="line">  r7 = r7;</span><br><span class="line">  r4 = [r0 retain];</span><br><span class="line">  r1 = @selector(HandleMsgList:MsgList:);</span><br><span class="line">  [r6 HandleMsgList:r2 MsgList:STK3];</span><br></pre></td></tr></table></figure>
<p>objc_ivar_offset_CMessageMgr_m_oMsgDB 就是     CMessageDB *m_oMsgDB;<br>也就是调用了 CMessageDB的GetMsgByCreateTime:r10</p>
<p>PS:<br><img src="https://everettjf.github.io/stuff/eimkit/1466141798790.png" alt="img"></p>
<blockquote>
<p> 在hopper中能看到不少日志信息，而且写明了当前实现文件的文件名。<br>后缀是.mm，当然不止这一个，微信好多类都是Objective C++实现的。包括消息主界面的 BaseMsgContentViewController.mm，以及下面CMessageMgr中的很多类。（猜测，微信的初期开发人员不少做Windows下C++开发客户端的哈。C开头的类……）</p>
</blockquote>
<p>这个CMessageMgr也是Objective C++开发 。不过hopper能看出 GetMsgByCreateTime: 内部调用了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int -[CMessageDB GetMsg:Where:order:Limit:](int arg0) &#123;</span><br></pre></td></tr></table></figure>
<p>内部又调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r11 = *objc_ivar_offset_CMessageDB_m_oMMDB;</span><br><span class="line"> r0 = *(r6 + r11);</span><br><span class="line"> r3 = *0x26b20d8;</span><br><span class="line"> asm&#123; stmeq.w    sp, &#123;r4, r10&#125; &#125;;</span><br><span class="line"> arg_8 = r5;</span><br><span class="line"> r5 = r8;</span><br><span class="line"> r0 = [r0 GetMessagesByChatName:r5 onProperty:r3 where:STK1 order:STK0 limit:STK-1];</span><br></pre></td></tr></table></figure>
<p>调用了成员CMMDB的 GetMessagesByChatName方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface CMessageDB : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    CMMDB *m_oMMDB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CMMDB的 GetMessagesByChatName方法内部如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = [arg0 GetMessageTable:r11];</span><br><span class="line">r0 = [res getObjectsWhere:r10 onProperties:r4 orderBy:STK0 limit:STK-1];</span><br></pre></td></tr></table></figure>
<p>也就是对 CMMDB::GetMessageTable 的返回值调用了getObjectsWhere方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void * -[CMMDB GetMessageTable:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">    r4 = [[CMMDB messageTableName:arg2] retain];</span><br><span class="line">    r5 = [[self m_db] retain];</span><br><span class="line">    r3 = [DBMessage class];</span><br><span class="line">    r6 = [[r5 getTable:r4 withClass:r3] retain];</span><br><span class="line">    r0 = loc_215a20c(r6, @selector(getTable:withClass:));</span><br></pre></td></tr></table></figure>
<p>调用了 m_db(    WCDataBase *m_db;)  的 getTable:withClass方法。再看进入 就是返回 WCDataBaseTable类型。</p>
<p>看看CMMDB的头文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@interface CMMDB : NSObject &lt;WCDataBaseEventDelegate&gt;</span><br><span class="line">&#123;</span><br><span class="line">    NSRecursiveLock *m_lockMMDB;</span><br><span class="line">    NSMutableSet *m_setMessageCreatedTable;</span><br><span class="line">    NSMutableSet *m_setMessageExtCreatedTable;</span><br><span class="line">    OpLogDB *m_oplogWcdb;</span><br><span class="line">    WCDataBase *m_db;</span><br><span class="line">    WCDataBaseTable *m_tableContact;</span><br><span class="line">    WCDataBaseTable *m_tableContactExt;</span><br><span class="line">    WCDataBaseTable *m_tableContactMeta;</span><br><span class="line">    WCDataBaseTable *m_tableQQContact;</span><br><span class="line">    WCDataBaseTable *m_tableSendMsg;</span><br><span class="line">    WCDataBaseTable *m_tableUploadVoice;</span><br><span class="line">    WCDataBaseTable *m_tableDownloadVoice;</span><br><span class="line">    WCDataBaseTable *m_tableRevokeMsg;</span><br><span class="line">    WCDataBaseTable *m_tableEmoticon;</span><br><span class="line">    WCDataBaseTable *m_tableEmoticonUpload;</span><br><span class="line">    WCDataBaseTable *m_tableEmoticonDownload;</span><br><span class="line">    WCDataBaseTable *m_tableEmoticonPackage;</span><br><span class="line">    WCDataBaseTable *m_tableBottle;</span><br><span class="line">    WCDataBaseTable *m_tableBottleContact;</span><br><span class="line">    WCDataBaseTable *m_tableMassSendContact;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是根据要获取的表类型（这里是DBMessage class）获取到对应的WCDataBaseTable实例，用来操作某个表。</p>
<p>PS：<br>WCDataBase 就是对sqlite的封装了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface WCDataBase : NSObject &lt;WCDBCorruptReportInterface, WCDBHandlesPoolProtocol&gt;</span><br><span class="line">&#123;</span><br><span class="line">    WCDBHandlesPool *m_handlesPool;</span><br><span class="line">    struct sqlite3 *m_dbHandle;</span><br><span class="line">    NSData *m_dbEncryptKey;</span><br><span class="line">    BOOL m_isMemoryOnly;</span><br><span class="line">    NSString *m_nsDBPath;</span><br><span class="line">    NSString *m_nsDBFilePath;</span><br><span class="line">    NSString *m_nsDBName;</span><br><span class="line">    NSRecursiveLock *m_oLock;</span><br><span class="line">    unsigned int m_databaseID;</span><br><span class="line">    unsigned int m_initTime;</span><br><span class="line">    id &lt;WCDataBaseEventDelegate&gt; m_eventDelegate;</span><br><span class="line">    WCDBCorruptReport *m_corruptReport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步跟踪调用，会到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int -[WCDataBase getObjectsOfClass:fromTable:onProperties:where:orderBy:limit:getError:](? arg0) &#123;</span><br></pre></td></tr></table></figure>
<p>这里就是对sqlite的本地查询了。</p>
<p>就到这里吧，知道了大体流程。但貌似有个问题，这一溜下来都是在主线程干的事情，不过看来足够快了。</p>
<p>PS：微信的本地sqlite数据库设计及Objective C++的封装有时间可以学习下。</p>
<h2 id="新消息"><a href="#新消息" class="headerlink" title="新消息"></a>新消息</h2><p>上面找到了首次打开聊天界面时加载历史聊天消息的调用栈。</p>
<p>我还想知道，在会话界面时，新消息到来时的调用栈。那就进入聊天界面后，再下载断点，然后用另一个手机给这个账号发消息（自己发也行啊），然后看调用栈。</p>
<p>首先进入聊天消息页面，然后再次下断点到 preCreateMessageContentNode方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(lldb) br s -a 0x16f1444</span><br><span class="line">Breakpoint 4: where = WeChat`___lldb_unnamed_function80337$$WeChat, address = 0x016f1444</span><br><span class="line">(lldb) c</span><br><span class="line">error: Process is running.  Use &apos;process interrupt&apos; to pause execution.</span><br><span class="line">Process 67776 stopped</span><br><span class="line">* thread #1: tid = 0x214590, 0x016f1444 WeChat`___lldb_unnamed_function80337$$WeChat, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 4.1</span><br><span class="line">    frame #0: 0x016f1444 WeChat`___lldb_unnamed_function80337$$WeChat</span><br><span class="line">WeChat`___lldb_unnamed_function80337$$WeChat:</span><br><span class="line">-&gt;  0x16f1444 &lt;+0&gt;: push   &#123;r4, r5, r6, r7, lr&#125;</span><br><span class="line">    0x16f1446 &lt;+2&gt;: add    r7, sp, #0xc</span><br><span class="line">    0x16f1448 &lt;+4&gt;: push.w &#123;r8, r10, r11&#125;</span><br><span class="line">    0x16f144c &lt;+8&gt;: sub.w  r4, sp, #0x20</span><br><span class="line">(lldb) bt</span><br><span class="line">* thread #1: tid = 0x214590, 0x016f1444 WeChat`___lldb_unnamed_function80337$$WeChat, queue = &apos;com.apple.main-thread&apos;, stop reason = breakpoint 4.1</span><br><span class="line">  * frame #0: 0x016f1444 WeChat`___lldb_unnamed_function80337$$WeChat</span><br><span class="line">    frame #1: 0x016f2516 WeChat`___lldb_unnamed_function80343$$WeChat + 990</span><br><span class="line">    frame #2: 0x018df210 WeChat`___lldb_unnamed_function87462$$WeChat + 472</span><br><span class="line">    frame #3: 0x018df44e WeChat`___lldb_unnamed_function87463$$WeChat + 398</span><br><span class="line">    frame #4: 0x01f6e3a2 WeChat`___lldb_unnamed_function115325$$WeChat + 1242</span><br><span class="line">    frame #5: 0x2433e5ce Foundation`__NSThreadPerformPerform + 386</span><br><span class="line">    frame #6: 0x235c5fae CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 14</span><br></pre></td></tr></table></figure>
<p>采用上面的方法可获得调用栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void -[BaseMsgContentViewController preCreateMessageContentNode:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">void -[BaseMsgContentViewController addMessageNode:layout:addMoreMsg:](void * self, void * _cmd, void * arg2, char arg3, char arg4) &#123;</span><br><span class="line">void -[BaseMsgContentLogicController DidAddMsg:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">void -[BaseMsgContentLogicController OnAddMsg:MsgWrap:](void * self, void * _cmd, void * arg2, void * arg3) &#123;</span><br><span class="line">void -[CMessageMgr MainThreadNotifyToExt:](void * self, void * _cmd, void * arg2) &#123;</span><br><span class="line">__NSThreadPerformPerform</span><br><span class="line">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span><br></pre></td></tr></table></figure>
<p>根据调用栈，大体得知 CMessageMgr MainThreadNotifyToExt 分发出消息。又到了CMessageMgr类。</p>
<p>上一个方法是__NSThreadPerformPerform，可知是从其他线程使用perform过来的。（perform到主线程会加入到主线程的RunLoop中）</p>
<p>看看MainThreadNotifyToExt的参数。断点到第一行代码：</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1466238259094.png" alt="img"></p>
<p>lldb查看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(lldb) po $r0</span><br><span class="line">po&lt;CMessageMgr: 0x147afbe0&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po $r0</span><br><span class="line">&lt;CMessageMgr: 0x147afbe0&gt;</span><br><span class="line"></span><br><span class="line">(lldb) po (char*)$r1</span><br><span class="line">&quot;MainThreadNotifyToExt:&quot;</span><br><span class="line"></span><br><span class="line">(lldb) po $r2</span><br><span class="line">&#123;</span><br><span class="line">    1 = 1;</span><br><span class="line">    2 = &quot;wxid_pamzqdzakikt21&quot;;</span><br><span class="line">    3 = &quot;&#123;m_uiMesLocalID=394, m_ui64MesSvrID=8508546064571928607, m_nsFromUsr=wxi*t21~19, m_nsToUsr=wxi*h12~19, m_uiStatus=3, type=1, msgSource=\&quot;\&quot;&#125; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(lldb) po [$r2 class]</span><br><span class="line">__NSDictionaryM</span><br><span class="line">(lldb) po [[$r2 objectForKey:@&quot;3&quot;] class]</span><br><span class="line">CMessageWrap</span><br><span class="line"></span><br><span class="line">(lldb) po [[$r2 objectForKey:@&quot;2&quot;] class]</span><br><span class="line">__NSCFString</span><br><span class="line"></span><br><span class="line">(lldb) po [[$r2 objectForKey:@&quot;1&quot;] class]</span><br><span class="line">__NSCFString</span><br></pre></td></tr></table></figure>
<p>可知参数是个NSDictionary，key分别为字符串1 2 3，分别是  NSString NSString 以及CMessageWrap。</p>
<p>可知CMessageWrap是后台线程准备好的。</p>
<p>hopper能能看到大体流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">center = [MMServiceCenter defaultCenter]</span><br><span class="line">service = getService:[MMExtensionCenter class]</span><br><span class="line">IMsgExt ext = service getExtension:[IMsgExt class]</span><br><span class="line">然后使用IMsgExt分发消息。</span><br></pre></td></tr></table></figure>
<p>IMsgExt协议如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@protocol IMsgExt</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">- (void)OnAddMsg:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnAddMsgForSpecialSession:(NSString *)arg1 MsgList:(NSArray *)arg2;</span><br><span class="line">- (void)OnAddMsgListForSession:(NSDictionary *)arg1 NotifyUsrName:(NSSet *)arg2;</span><br><span class="line">- (void)OnBeginDownloadAppData:(CMessageWrap *)arg1;</span><br><span class="line">- (void)OnBeginDownloadImage:(CMessageWrap *)arg1;</span><br><span class="line">- (void)OnBeginDownloadVideo:(CMessageWrap *)arg1;</span><br><span class="line">- (void)OnChangeMsg:(NSString *)arg1 OpCode:(unsigned long)arg2;</span><br><span class="line">- (void)OnDelMsg:(NSString *)arg1;</span><br><span class="line">- (void)OnDelMsg:(NSString *)arg1 DelAll:(BOOL)arg2;</span><br><span class="line">- (void)OnDelMsg:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnGetNewXmlMsg:(NSString *)arg1 Type:(NSString *)arg2 MsgWrap:(CMessageWrap *)arg3;</span><br><span class="line">- (void)OnModMsg:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnMsgDownloadAppAttachExpiredFail:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnMsgDownloadThumbFail:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnMsgDownloadThumbOK:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnMsgDownloadVideoExpiredFail:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnMsgNotAddDBNotify:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnMsgNotAddDBSession:(NSString *)arg1 MsgList:(NSArray *)arg2;</span><br><span class="line">- (void)OnPreAddMsg:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">- (void)OnReceiveSight:(CMessageWrap *)arg1;</span><br><span class="line">- (void)OnRevokeMsg:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2 ResultCode:(unsigned long)arg3 ResultMsg:(NSString *)arg4 EducationMsg:(NSString *)arg5;</span><br><span class="line">- (void)OnSendSight:(NSString *)arg1;</span><br><span class="line">- (void)OnShowPush:(CMessageWrap *)arg1;</span><br><span class="line">- (void)OnUnReadCountChange:(NSString *)arg1;</span><br><span class="line">- (void)OnUpdateVideoStatus:(NSString *)arg1 MsgWrap:(CMessageWrap *)arg2;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>具体细节就不继续分析了。大体知道了与UI相关的流程。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h2><p>微信这种把消息的view 预创建到实体中，且不销毁。不销毁的意思是：退出界面会话时不会销毁；不断的下拉消息会不断的创建。一眼感觉不太考虑，看看微信内存占用情况。</p>
<p>首先，把微信进程结束后，重新打开。<br><img src="https://everettjf.github.io/stuff/eimkit/1466242953914.png" alt="img"></p>
<p>在这种状态下看看内存：</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1466240808797.png" alt="img"></p>
<p>RSIZE=52M</p>
<p>然后，进入聊天界面：</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1466240901871.png" alt="img"></p>
<p>RSIZE=56M</p>
<p>然后，使劲发消息（图片、文字各种消息），400多条，全部下拉下来。</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1466241021593.png" alt="img"></p>
<p>RSIZE=81M</p>
<p>这样看来，由于在一个会话中打开很多消息的概率较少，且内存占用还是可接受的。占用81M感觉还是比较少的。看来这种方案还是比较靠谱的。</p>
<p>这种方案也有性能上的优势，就是不需要重复设置消息View的内容（因为preCreate了嘛），牺牲了内存，提高了性能。</p>
<h2 id="ViewController"><a href="#ViewController" class="headerlink" title="ViewController"></a>ViewController</h2><p>微信会对ViewController进行缓存，也就是对同一个用户的消息打开两次，ViewController的地址是相同的。</p>
<p>应该会有个缓存策略，有空研究研究。</p>
<h2 id="QQ等其他实现方案"><a href="#QQ等其他实现方案" class="headerlink" title="QQ等其他实现方案"></a>QQ等其他实现方案</h2><p>要支持IM界面的多种类型消息展示，首先想到的肯定是使用多种Cell。例如：TextCell, ImageCell 等。经典的QQ，其实就是这种方式。可以用Reveal看看。</p>
<p><img src="https://everettjf.github.io/stuff/eimkit/1466241507427.png" alt="img"></p>
<h2 id="cellForRowAtIndexPath中改变frame的问题"><a href="#cellForRowAtIndexPath中改变frame的问题" class="headerlink" title="cellForRowAtIndexPath中改变frame的问题"></a>cellForRowAtIndexPath中改变frame的问题</h2><p>如果采用QQ这种使用Cell的方案，有个UI上的细节问题要注意。<a href="https://everettjf.github.io/2016/06/18/little-chat-ui-bug-resolve" target="_blank" rel="external">见这篇文章</a>。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><p>根据微信上面的消息界面实现，我实现了一个很简单的类似机制的界面Demo <a href="https://github.com/everettjf/WeChatLikeMessageDemo" target="_blank" rel="external">https://github.com/everettjf/WeChatLikeMessageDemo</a> 。</p>
<p>实现过程中发现这种机制有个好处，就是在preCreate消息时，可以提前（在heightForRowAtIndexPath之前）知道cell的高度，也就很方便的解决了Cell动态高度这个问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>逆向可以让我们了解一个App的实现方法（尤其是优秀未开源的App哈），学习这些优秀的App可以辅助正向开发。</p>
<p>推荐《iOS应用逆向工程》这本书，以及 <a href="http://iosre.com" target="_blank" rel="external">http://iosre.com</a> 论坛。</p>
<p>转载于everettjf;</p>

      
    </div>

    <div>
      
        
<div id="wechat_subscriber" style="display: block； padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="leneqi wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您添加上面的微信号，一起共同探讨！</div>
</div>

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS开发/" rel="tag">#iOS开发</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/25/2016-05-25-my-ios-debug-cheatsheet/" rel="next" title="iOS Debug 速查表">
                <i class="fa fa-chevron-left"></i> iOS Debug 速查表
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/22/postName/" rel="prev" title="postName">
                postName <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://o96l27g1f.bkt.clouddn.com/8440013.png"
               alt="leneqi" />
          <p class="site-author-name" itemprop="name">leneqi</p>
          <p class="site-description motion-element" itemprop="description">Goals determine what you are going to be</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">6</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/10886189" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="wechat" target="_blank" title="微信">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  微信
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://weibo.com/10886189" title="我的微博" target="_blank">我的微博</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#背景"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#准备"><span class="nav-number">2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#初步窥探"><span class="nav-number">3.</span> <span class="nav-text">初步窥探</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#定位Controller"><span class="nav-number">3.1.</span> <span class="nav-text">定位Controller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察Views"><span class="nav-number">3.2.</span> <span class="nav-text">观察Views</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reveal"><span class="nav-number">3.2.1.</span> <span class="nav-text">Reveal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MMTableView"><span class="nav-number">3.2.2.</span> <span class="nav-text">MMTableView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MessageNodeView"><span class="nav-number">3.2.3.</span> <span class="nav-text">MessageNodeView</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单总结"><span class="nav-number">3.2.4.</span> <span class="nav-text">简单总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#观察Controller"><span class="nav-number">3.3.</span> <span class="nav-text">观察Controller</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#NSMutableArray-m-arrMessageNodeData"><span class="nav-number">3.3.1.</span> <span class="nav-text">NSMutableArray *m_arrMessageNodeData;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-vector"><span class="nav-number">3.3.2.</span> <span class="nav-text">struct vector> m_messageNodeClass;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-preCreateMessageXXXXNode"><span class="nav-number">3.3.3.</span> <span class="nav-text">- (void) preCreateMessageXXXXNode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TimeNode"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">TimeNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ContentNode"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">ContentNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#canCreateMessageNodeViewInstanceWithMessageWrap"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">canCreateMessageNodeViewInstanceWithMessageWrap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#initWithMessageWrap"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">initWithMessageWrap</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#继续研究"><span class="nav-number">4.</span> <span class="nav-text">继续研究</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#准备工作"><span class="nav-number">4.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#历史消息"><span class="nav-number">4.2.</span> <span class="nav-text">历史消息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#历史消息来源"><span class="nav-number">4.3.</span> <span class="nav-text">历史消息来源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#新消息"><span class="nav-number">4.4.</span> <span class="nav-text">新消息</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#其他"><span class="nav-number">5.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#内存占用"><span class="nav-number">5.1.</span> <span class="nav-text">内存占用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ViewController"><span class="nav-number">5.2.</span> <span class="nav-text">ViewController</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#QQ等其他实现方案"><span class="nav-number">5.3.</span> <span class="nav-text">QQ等其他实现方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cellForRowAtIndexPath中改变frame的问题"><span class="nav-number">5.4.</span> <span class="nav-text">cellForRowAtIndexPath中改变frame的问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Demo"><span class="nav-number">6.</span> <span class="nav-text">Demo</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">7.</span> <span class="nav-text">总结</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">leneqi</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'yyyyyy';
      var disqus_identifier = '2016/06/19/2016-06-19-reverse-explore-wechat-message-design/';
      var disqus_title = "逆向探索微信消息界面实现";
      var disqus_url = 'http://yoursite.com/2016/06/19/2016-06-19-reverse-explore-wechat-message-design/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  




  
  
  

  

  

</body>
</html>
